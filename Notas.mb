JAVA
Arboles y HEAP
Clase 1/2
    Objetos que intercambian mensajes
    Clase
        Variables (referenciales y primitivas) //Estado
        Metodos //Comportamiento

    Archivo: Contacto.java //Nombre de clase con mayuscula y CamelCase

        package whatsapp; //A que paquete pertenece 
        import java.awt.Image; //importo clase Image

        public class Contacto { //Clase publica Contacto
            //Variables de instancia 
            private String nombre; // modificadorDeAcceo tipoDato nombreVar
            private Image imagen;
            private int id;
        
            //Constructor Vacio
            public Contacto(){
            }
            //Constructor con argumentos
            public Contacto(String nombre, Image imagen, int id){
                this.nombre = nombre;
                this.imagen = imagen;
                this.id = id;
            }
            //Sobrecarga de Constructores
            public Contacto(int id){
                this.id = id;
            }

            //Comportamientos
            public String getNombre() { //modificadorDeAcceo tipoDatoRetorno nombreMetodo (parametros)
                return nombre;
            }
            public void setNombre(String nombre) {
                this.nombre = nombre;
            }
            . . .
        }

        modificadorDeAcceo = private, public
        tipoDatoRetorno = void (nada), int, String ...

    Tipos de Datos
        Primitivos (Se guarda en STACK)
            Entero: byte, short, int (32 bits), long (64 bits)
            Punto flotante: float y double
            Un carácter: char
            Lógico: boolean
        Referenciales (Clase) (Se guarda en HEAP)
            NombreCLase nomVar;
            nomVar = new NombreClase();
            //Tambien se puede declarar de esta manera
            NombreClase nomVar = new NombreClase();

    Valor por defecto en Variables de instancia:
        boolean = false;
        char = '\uoooo' (nulo);
        byte/short/int/long = 0;
        float/double = 0.0;
        objeto = null;

    Clases wrappers: clases de objetos con metodos por defecto ya creados dentro del paquete java.lang(ya disponible sin import).
        primitivo = Wrapper
        char = Character
        boolean = Boolean
        byte = Byte
        short = Short
        int = Integer
        long = Long
        float = Float
        double = Double
    Autoboxing/Boxing-Unboxing:(cambio de tipo primitivo a wrapper)
        Antes:
            Integer nro = new Integer(3);
            int num = nro.intValue();
        Ahora
            Integer nro = 3;
            int num = nro;

    Pasos al crear instancia de objeto (new()):
        1. Se aloca espacio para la variable
        2. Se aloca espacio para el objeto en la HEAP y se inicializan los atributos con valores por defecto.
        3. Se inicializan explícitamente los atributos del objeto.
        4. Se ejecuta el constructor (parecido a un método que tienen el mismo nombre de la clase)
        5. Se asigna la referencia del nuevo objeto a la variable.

    Variables:
        Variables locales a un metodo
            -Es necesario inicializar
            -Se almacena en STACK
        Variables de instancia
            -Se almacena en HEAP

    static
        Variable static: es una unica variable (compartida) para todas las instancia de un objeto. Una sola referencia en memoria
            private static int ultCont;
        Metodo static: se utilizan cuando se necesita algún comportamiento que no depende de una instancia particular
            public static int getUltCont{
                return ultCont;
            }

    Arreglos
        - Un objeto que ahce referencia a un conjunto
        - Heterogeneos
        - Se guardan en posiciones contiguas
        - nombre.length cantidad de espacio reservado
    Declaracion:
        tipoDato[] nomArr = new tipoDato[cant]; // Se reserva cant posiciones de ese tipo
    Inicializacion:
        nomArr[0] = x;
    Declaracion/Iniciacizacion:
        tipoDato[] nomArr = {new tipoDato(), new tipoDato(),new tipoDato()}
        String[] nomArr = {"example0", "example1",'example2'}

    Recorridos
        For Tradicional
            for (int i=0; i<a.length;i++)
                result = result + a[i];
        For-each:
            for (int valor: a) // para cada elemento elto de tipo int, en el arreglo a
                result = result + valor;
    Matriz
        int[][] notas = new int[2][3];

    Pasaje de parametros (siempre por valor)
        En JAVA siempre se hace una copia de los parametros reales.

        Parametros formales
            Son los parametros en la definicion del metodo
        Parametros reales
            Son los parametros en la invocacion al metodo
        
        Tipo primitivo: se hace una copia.
        Wrapper: crea una nueva instancia cuando le damos un valor.

        Si pasamos un tipo de dato referencial (objeto) se pueden modificar el estado mediante los setters.
    

Clase 3
    Herencia: Una clase hereda los atributos y comportamientos de otra clase
        extends
            public class Camioneta extends Vehiculo { // La clase Camioneta es una subclase de Vehiculo
                ...
            }
        Sobreecritura de metodos (super) @Override
            public String detalles() {
                return super.detalles() + " sigo agregando"; //Con super puedo llamar a metodos de la super Clase
            }
        Habilitacion de metodos segun la jerarquia de herencia
        Casting: conversion de tipos
        Upcasting: casting hacia arriba en la jerarquia de herencia, es SEGURO.
            Vehiculo vc = new Camion(); // vc solo puede utilizar los metodos de Vehiculo y los metodos sobreescritos (binding dinamico) de Camion
        Downcasting: casting hacia abajo en la jerarquia de herencia.
            Integer x = (Integer)lista.elemento(2);

    Clase object: clase base de todas las clases sin extends
        public boolean equals(Object obj){} // Se puede sobreescribir para que compare los atributos
            obj1.equals(obj2); //Compara si las dos referencias a memoria son iguales.
        public String toString(){}, // Se puede sobreescribir para imprimir los atributos
            ob1.toString(); //Devuelve 

    Clases abstractas: clase que sirve para modelar un concepto abastracto,agrupar clases y no se puede instanciar.
        public abstract class FiguraGeometrica {
            //atributos
            //metodos
            public abstract void dibujar(); //Metodo delegado a la subclase
        }

    Listas
        Operaciones:
            elemento(int pos): retorna el elemento de la posición indicada
            incluye(Object elem): retorna true si elem está en la lista, false en caso contrario
            agregarEn(Object elem, int pos): agrega el elemento elem en la posición pos
                agregarInicio(Object elem): agrega al inicio de la lista
                agregarFinal(Object elem): agrega al final de la lista
            eliminarEn(int pos): elimina el elemento de la posición pos
            eliminar(Object elem): elimina, si existe, el elemento elem
            esVacia(): retorna true si la lista está vacía, false en caso contrario
            tamanio(): retorna la cantidad de elementos de la lista
            
            comenzar(): se prepara para iterar los elementos de la lista
            proximo(): retorna el elemento y avanza al próximo elemento de la lista.
            fin(): determina si llegó o no al final de la lista, retorna true si no hay mas elementos, false en
            caso contrario
        
        Tipo especifico (no hay que hacer casting, y necesitamos una clase por cada tipo a almacenar)
        ListaDeEnteros(clase abstracta)
            ListaDeEnterosConArreglos
            ListaDeEnterosEnlazada

        Tipo Object (estructura generica, pero hay que hacer Downcasting)
        Lista heterogeneas de objetos
            Para recuperar un objeto de la lista hay que hacer Downcasting
                Integer x = (Integer)lista.elemento(2);
            
        Tipos genericos: permiten abstraerse de los tipos
            Definicion:
            public class ListaEnlazadaGenerica<T> extends ListaGenerica<T>{
                private NodoGenerico<T> inicio;
                ...
            }
            Instanciacion:
            ListaEnlazadaGenerica<Integer> lista = new ListaEnlazadaGenerica<Integer>();
            lista.agregarFinal(new Integer(50));
            ListaEnlazadaGenerica<Alumno> lista = new ListaEnlazadaGenerica<Alumno>();
            lista.agregarFinal(new Alumno(“Peres, Juan”, 3459));

Clase 4
    Arbol: coleccion de nodos 
        Camino: cantidad de nodos por debajo de n
        Profundidad: es la longitud del unico camino desde la raiz hasta el nodo - 1
        Grado: numero de hijos del nodo
        Altura: la longitud del camino mas largo de n a su ultima hoja
        Ancestro/Descendiente : todos los nodos que esten por debajo del nodo
        Arbol binario lleno: si tiene todos los nodos con 2 hojas y su altura maxima
        Cantidad de nodos en un arbol binario lleno: altura = h, 2^(h+1) - 1
        Cantidad de nodos en un arbol binario completo: altura = h, min(2^h) entre max(2^(h+1) - 1)

    Representacion : hijo izquierdo - hijo derecho
    Recorridos
        - Preorden: (recursivo)(abajo) se procesa la raiz, luego el hijo izquierdo y despues el hijo derecho
        public void preorden(){
            imprimir (dato);
            si (tiene hijo_izquierdo)
                hijoIzquierdo.preorden();
            si (tiene hijo_derecho)
                hijoDerecho.preorden();
        }
        - Postorden: (recursivo)(arriba) se procesa los hijos, izquierdo y derecha, y luego la raiz

        - Inorden: (recursivo) se procesa el hijo izquierdo, luego la raiz y despues el hijo derecho
        - Por niveles: primero la raiz, luego los hijos, los hijos de estos, etc
        public void porNiveles(){
            encolar(raiz)
            mientras(cola no se vacie){
                desencolar(v);
                imprimir (dato de v);
                si (tiene hijo_izquierdo)
                    encolar(hijo_izquierdo);
                si (tiene hijo_derecho)
                    encolar(hijo_derecho);
            }
        }
        Para saber el recorrido de a cuerdo con solamente la secuencia de nodos, primero hay que ver donde esta la raiz.
        
        Arboles de expresion (logicas, aritmeticas)
                    - Nodos internos son operadores
            - Nodos externos son operandos
        -Lo utilizan los compiladores para anlizar
        -Traducir expresiones a notaciones: 
            -Postfija/Sufija (Postorden) (no necesita uso de parentesis)
                Algoritmo:
                tomo un caracter
                mientras(exista caracter)
                    si es un operado: creo un nodo y lo apilo
                    si es un operador:
                        creo un nodo R
                        desapilo y lo agrego como hijo derecho
                        desapilo y lo agrego como hijo izquierod de r
                        apilo r
                    tomo otro caracter 
            -Prefija (Preorden) (no necesita uso de parentesis) (de raiz hacia abajo/ recursivo)(primero operadores luego operandos)
                Algoritmo:
                ArbolExpresion(A: ArbolBin,exp: string)
                si exp nulo: nada
                si es un operador: 
                    creo nodo raiz
                    ArbolExpresion(subArbIzq de R, exp(sin 1 caracter))
                    ArbolExpresion(subArbDer de R, exp(sin 1 caracter))
                si es un operando:
                    creo un nodo(hoja)
            -Infija (Inorden)(hiper-parentisada por niveles/ ambigua)
Clase 5
    Diagrama UML
    ArbolBinario<T> (Homogeneos respecto al tipo de dato)
        T dato;
        ArbolBinario<T> hijoDerecho
        ArbolBinario<T> hijoIzquierdo
        Metodos
            getDato();
            setDato();
            getHijoDerecho();
            getHijoIzquierdo();
            agregarHijoDerecho(ArbolBinario<T> hijo);
            agregarHijoIzquierdo(ArbolBinario<T> hijo);
            eliminarHijoDerecho(arbolBinario<T> hijo);
            agregarHijoIzquierdo(ArbolBinario<T> hijo);
            esVacio();
            esHoja();
            tieneHijoDerecho();
            tieneHijoIzquierdo();
        Creacion:
            - de abajo hacia arriba
            - primero ultimas hojas y por ultimo la raiz
                -Creo padres y luego hijos
        Recorridos:
            Preorden
                Se procesa primero la raíz y luego sus hijos, izquierdo y derecho.
                Algoritmo:
                    En la misma clase:
                        public void printPreorden(){
                            System.out.println(this.getDato()); //Se puede agregar a una lista tambien, en vez de imprimir
                            if (this.tieneHijoIzquierdo){
                                this.getHijoIzquierdo().printPreorden();
                            }
                            if (this.tieneHijoDerecho){
                                this.getHijoDerecho().printPreorden();
                            } 
                        }
                    En otra clase:
                        public void preorden(ArbolBinario<T> arbol){
                            System.out.println(arbol.getDato());
                            if (arbol.tieneHijoIzquierdo){
                                this.preorden(arbol.getHijoIzquierdo);
                            }
                            if (arbol.tieneHijoDerecho){
                                this.preorden(arbol.getHijoDerecho);
                            } 
                        }
            Inorden
                Se procesa el hijo izquierdo, luego la raíz y último el hijo derecho
            Postorden
                Se procesan primero los hijos, izquierdo y derecho, y luego la raíz
            Por niveles
                Se procesan los nodos teniendo en cuenta sus niveles, primero la raíz, luego los hijos, los hijos de éstos, etc.
                Se utiliza una cola, se encolan los elemntos y a medida que se pasa de niveles se van encolando null
                Algoritmo:
                    public void recorridoProNiveles(){
                        ArbolBinario<T> arbol = null;'
                        ColaGenerica<ArbolBinario<T>> cola = new ColaGenerica<ArbolBinario<T>>();
                        cola.encolar(this);
                        cola.encolar(null);
                        while (!cola.esVacia()){    
                            arbol = cola.desencolar();
                            if (arbol != nul){
                                System.out.print(arbol.getDato());
                                if (arbol.tieneHijoIzquierdo){
                                    cola.encolar(arbol.getHijoIzquierdo);}
                                if (arbol.tieneHijoDerecho){
                                    cola.encolar(arbol.getHijoDerecho); }
                            } else if (!cola.esVacia()){
                                System.out.println();
                                cola.encolar(null);
                            }
                        }
                    }
            Algoritmo para saber si esta lleno el arbol:
                Algoritmo:
                    public boolean lleno() {
                        ArbolBinario<T> arbol = null;
                        ColaGenerica<ArbolBinario<T>> cola = new ColaGenerica<ArbolBinario<T>>();
                        boolean lleno = true;
                        int cant_nodos=0;
                        int nivel= 0;
                        cola.encolar(this);
                        cola.encolar(null);
                        while (!cola.esVacia() && lleno) {
                            arbol = cola.desencolar();
                            if (arbol != null) {
                                System.out.print(arbol.getDatoRaiz());
                                if (!arbol.getHijoIzquierdo().esvacio()) {
                                    cola.encolar(arbol.getHijoIzquierdo());
                                    cant_nodos++;
                                }
                                if (!(arbol.getHijoDerecho().esvacio())) {
                                    cola.encolar(arbol.getHijoDerecho());
                                    cant_nodos++;
                                }
                            } else if (!cola.esVacia()) {
                                if (cant_nodos == Math.pow(2, ++nivel)){ // ++nivel Primero incrementa y luego retorna el valor incrementado
                                    cola.encolar(null);
                                    cant_nodos=0;
                                    System.out.println();
                                } else {
                                    lleno=false;
                                    }
                            }
                        }
                        return lleno;
                    }
                
        Arbol de Expresion:
            Convertir expresion posfija en arbol de expresion:
                Idea: apila los elementos que no sean operadores, al encontrarse con un operador agrega los operadores como hojas de los operandos
                Algoritmo:
                    public ArbolBinario<Character> convertirPostfija(String exp) {
                    Character c = null;
                    ArbolBinario<Character> result;
                    PilaGenerica<ArbolBinario<Character>> p = new PilaGenerica<ArbolBinario<Character>>();
                    
                    for (int i = 0; i < exp.length(); i++) {
                        c = exp.charAt(i);
                        result = new ArbolBinario<Character>(c);
                        if ((c == '+') || (c == '-') || (c == '/') || (c == '*')) {
                            // Es operador
                            result.agregarHijoDerecho(p.desapilar());
                            result.agregarHijoIzquierdo(p.desapilar ());
                            }
                        p.apilar(result);
                        }
                    return (p.desapilar());
                    }
            Convertir expresion prefija en arbol de expresion
                Idea: tomamos el primer elemento del string, ir agregando izquierda, luego derecha del string-1
                Nota: al momento de hacer exp.delete(0,1) borra el elemento y lo modifica dentro del objeto - el caso base son los operandos, y el recursivo los operadores
                Algoritmo:
                    public ArbolBinario<Character> convertirPrefija(StringBuffer exp) {
                    Character c = exp.charAt(0);
                    ArbolBinario<Character> result = new ArbolBinario<Character>(c);
                    if ((c == '+') || (c == '-') || (c == '/') || c == '*') {
                        // es operador
                        result.agregarHijoIzquierdo(this.convertirPrefija(exp.delete(0,1))); //Aca borras un elemento de exp
                        result.agregarHijoDerecho(this.convertirPrefija(exp.delete(0,1))); // Aca borras otro mas, al momento de hacer delete() borras y queda guardado sin ese caracter
                    }
                    // es operando
                    return result;
                    }
            Evaluacion de un arbol de expresion:
                Idea: si no es operador, retorno integer. Si es operador retorno la operacion entre los dos operadores.
                Nota: recursivo
                Algoritmo:
                    public Integer evaluar(ArbolBinario<Character> arbol) {
                        Character c = arbol.getDato();
                        if ((c == '+') || (c == '-') || (c == '/') || c == '*') {
                            // es operador
                            int operador_1 = evaluar(arbol.getHijoIzquierdo());
                            int operador_2 = evaluar(arbol.getHijoDerecho());
                            switch (c) {
                                case '+':
                                    return operador_1 + operador_2;
                                case '-':
                                    return operador_1 - operador_2;
                                case '*':
                                    return operador_1 * operador_2;
                                case '/':
                                    return operador_1 / operador_2;
                            }
                        }
                        // es operando
                        return Integer.parseInt(c.toString());
                    }
CLase 6



